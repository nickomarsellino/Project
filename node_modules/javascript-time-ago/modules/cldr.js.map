{"version":3,"sources":["../source/cldr.js"],"names":["parse_CLDR","units","short","narrow","data","locale","Object","keys","main","time_units_formatting_rules","dates","fields","filter","unit","indexOf","parse_unit","reduce","locale_data","_unit","type","set_unit_rules","parse_CLDR_time_unit_formatting_rules","rules_CLDR","rules","previous","current","next","past","quantifier","replace","other","length","future","now","test"],"mappings":"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","file":"cldr.js","sourcesContent":["// import { isEqual } from 'lodash'\r\n\r\n// The generic time measurement units.\r\n// (other units like \"fri\" or \"thu\" are ignored)\r\n// (\"quarter\" is required by `Intl.RelativeTimeFormat`)\r\nexport const units = ['second', 'minute', 'hour', 'day', 'week', 'month', 'quarter', 'year']\r\n\r\n// Detects short and narrow flavours of labels (yr., mo., etc).\r\n// E.g. there are \"month\", \"month-short\", \"month-narrow\".\r\n// More on \"narrow\" vs \"short\":\r\n// http://cldr.unicode.org/translation/plurals#TOC-Narrow-and-Short-Forms\r\nconst short = /-short$/\r\nconst narrow = /-narrow$/\r\n\r\n// Converts locale data from CLDR format to this library's format.\r\n//\r\n// CLDR locale data example:\r\n//\r\n// ```json\r\n// {\r\n//   \"main\": {\r\n//     \"en-US-POSIX\": {\r\n//       \"identity\": {\r\n//         \"language\": \"en\",\r\n//         ...\r\n//       },\r\n//       \"dates\": {\r\n//         \"fields\": {\r\n//           \"year\": {\r\n//             \"displayName\": \"year\",\r\n//             \"relative-type--1\": \"last year\",\r\n//             \"relative-type-0\": \"this year\",\r\n//             \"relative-type-1\": \"next year\",\r\n//             \"relativeTime-type-future\": {\r\n//               \"relativeTimePattern-count-one\": \"in {0} year\",\r\n//               \"relativeTimePattern-count-other\": \"in {0} years\"\r\n//             },\r\n//             \"relativeTime-type-past\": {\r\n//               \"relativeTimePattern-count-one\": \"{0} year ago\",\r\n//               \"relativeTimePattern-count-other\": \"{0} years ago\"\r\n//             }\r\n//           },\r\n// ...\r\n// ```\r\n//\r\n// Parsed locale data example:\r\n//\r\n// ```json\r\n// {\r\n// \t\"long\":\r\n// \t{\r\n// \t\t...\r\n// \t\t\"second\": [\r\n// \t\t\t{\r\n// \t\t\t\t\"one\": \"a second ago\",\r\n// \t\t\t\t\"other\": \"{0} seconds ago\"\r\n// \t\t\t},\r\n// \t\t\t{\r\n// \t\t\t\t\"one\": \"in a second\",\r\n// \t\t\t\t\"other\": \"in {0} seconds\"\r\n// \t\t\t}\r\n// \t\t],\r\n// \t\t...\r\n// \t},\r\n// \t\"short\":\r\n// \t{\r\n// \t\t...\r\n// \t},\r\n// \t...\r\n// }\r\n// ```\r\nexport default function parse_CLDR(data)\r\n{\r\n\t// Extract `locale` from CLDR data\r\n\tconst locale = Object.keys(data.main)[0]\r\n\tconst time_units_formatting_rules = data.main[locale].dates.fields\r\n\r\n\treturn Object.keys(time_units_formatting_rules)\r\n\t.filter((unit) =>\r\n\t{\r\n\t\t// Take only the generic time measurement units\r\n\t\t// (skip exotic ones like \"fri\" on \"thu\").\r\n\t\treturn units.indexOf(parse_unit(unit).unit) >= 0\r\n\t})\r\n\t.reduce((locale_data, _unit) =>\r\n\t{\r\n\t\tconst { unit, type } = parse_unit(_unit)\r\n\t\treturn set_unit_rules(locale_data, type, unit, parse_CLDR_time_unit_formatting_rules(time_units_formatting_rules[_unit]))\r\n\t},\r\n\t// Parsed locale data\r\n\t{})\r\n}\r\n\r\n/**\r\n * Parses CLDR time unit formatting rules.\r\n * @param  {object} - CLDR time unit formatting rules.\r\n * @return {(object|string)}\r\n */\r\nfunction parse_CLDR_time_unit_formatting_rules(rules_CLDR)\r\n{\r\n\tlet rules = {}\r\n\r\n\t// \"relative\" values aren't suitable for \"ago\" or \"in a\" cases,\r\n\t// because \"1 year ago\" != \"last year\" (too vague for Jan 30th)\r\n\t// and \"in 0.49 years\" != \"this year\" (it could be Nov 30th).\r\n\t// Still including them here for `Intl.RelativeTimeFormat` polyfill.\r\n\r\n\t// \"yesterday\"\r\n\tif (rules_CLDR['relative-type--1'])\r\n\t{\r\n\t\trules.previous = rules_CLDR['relative-type--1']\r\n\t}\r\n\r\n\t// \"today\"\r\n\t/* istanbul ignore else */\r\n\tif (rules_CLDR['relative-type-0'])\r\n\t{\r\n\t\trules.current = rules_CLDR['relative-type-0']\r\n\t}\r\n\r\n\t// \"tomorrow\"\r\n\tif (rules_CLDR['relative-type-1'])\r\n\t{\r\n\t\trules.next = rules_CLDR['relative-type-1']\r\n\t}\r\n\r\n\t// Formatting past times.\r\n\t//\r\n\t// E.g.:\r\n\t//\r\n\t// \"relativeTime-type-past\":\r\n\t// {\r\n\t// \t\"relativeTimePattern-count-one\": \"{0} mo. ago\",\r\n\t// \t\"relativeTimePattern-count-other\": \"{0} mo. ago\"\r\n\t// }\r\n\t//\r\n\t/* istanbul ignore else */\r\n\tif (rules_CLDR['relativeTime-type-past'])\r\n\t{\r\n\t\tconst past = rules_CLDR['relativeTime-type-past']\r\n\t\trules.past = {}\r\n\r\n\t\t// Populate all quantifiers (\"one\", \"other\", etc).\r\n\t\tfor (const quantifier of Object.keys(past))\r\n\t\t{\r\n\t\t\trules.past\r\n\t\t\t[\r\n\t\t\t\tquantifier.replace('relativeTimePattern-count-', '')\r\n\t\t\t]\r\n\t\t\t= past[quantifier]\r\n\t\t}\r\n\r\n\t\t// Delete all duplicates of \"other\" rule.\r\n\t\tfor (const quantifier of Object.keys(rules.past))\r\n\t\t{\r\n\t\t\tif (quantifier !== 'other' && rules.past[quantifier] === rules.past.other)\r\n\t\t\t{\r\n\t\t\t\tdelete rules.past[quantifier]\r\n\t\t\t}\r\n\t\t}\r\n\r\n \t\t// If only \"other\" rule is present then \"rules\" is not an object and is a string.\r\n\t\tif (Object.keys(rules.past).length === 1)\r\n\t\t{\r\n\t\t\trules.past = rules.past.other\r\n\t\t}\r\n\t}\r\n\r\n\t// Formatting future times.\r\n\t//\r\n\t// E.g.:\r\n\t//\r\n\t// \"relativeTime-type-future\":\r\n\t// {\r\n\t// \t\"relativeTimePattern-count-one\": \"in {0} mo.\",\r\n\t// \t\"relativeTimePattern-count-other\": \"in {0} mo.\"\r\n\t// }\r\n\t//\r\n\t/* istanbul ignore else */\r\n\tif (rules_CLDR['relativeTime-type-future'])\r\n\t{\r\n\t\tconst future = rules_CLDR['relativeTime-type-future']\r\n\t\trules.future = {}\r\n\r\n\t\t// Populate all quantifiers (\"one\", \"other\", etc).\r\n\t\tfor (const quantifier of Object.keys(future))\r\n\t\t{\r\n\t\t\trules.future\r\n\t\t\t[\r\n\t\t\t\tquantifier.replace('relativeTimePattern-count-', '')\r\n\t\t\t]\r\n\t\t\t= future[quantifier]\r\n\t\t}\r\n\r\n\t\t// Delete all duplicates of \"other\" rule.\r\n\t\tfor (const quantifier of Object.keys(rules.future))\r\n\t\t{\r\n\t\t\tif (quantifier !== 'other' && rules.future[quantifier] === rules.future.other)\r\n\t\t\t{\r\n\t\t\t\tdelete rules.future[quantifier]\r\n\t\t\t}\r\n\t\t}\r\n\r\n \t\t// If only \"other\" rule is present then \"rules\" is not an object and is a string.\r\n\t\tif (Object.keys(rules.future).length === 1)\r\n\t\t{\r\n\t\t\trules.future = rules.future.other\r\n\t\t}\r\n\t}\r\n\r\n\t// // If `.past` === `.future` then replace them with `.other`.\r\n\t// // (only eligible for \"tiny\" and \"*-time\" locale data which is not part of CLDR)\r\n\t// if (isEqual(rules.past, rules.future))\r\n\t// {\r\n\t// \trules.other = rules.past\r\n\t// \tdelete rules.future\r\n\t// }\r\n\r\n\t// // If only \"other\" rule is defined for a time unit\r\n\t// // then make \"rules\" a string rather than an object.\r\n\t// if (Object.keys(rules).length === 1)\r\n\t// {\r\n\t// \trules = rules.other\r\n\t// }\r\n\r\n\treturn rules\r\n}\r\n\r\n/**\r\n * Sets time unit formatting rules in locale data.\r\n * @param {object} locale_data\r\n * @param {string} type\r\n * @param {string} unit\r\n * @param {object} rules\r\n * @return {object} Locale data.\r\n */\r\nfunction set_unit_rules(locale_data, type, unit, rules)\r\n{\r\n\tif (!locale_data[type])\r\n\t{\r\n\t\tlocale_data[type] = {}\r\n\t}\r\n\r\n\tlocale_data[type][unit] = rules\r\n\r\n\t// Populate \"now\" unit rules.\r\n\tif (unit === 'second' && rules.current)\r\n\t{\r\n\t\tlocale_data[type].now = rules.current\r\n\t}\r\n\r\n\treturn locale_data\r\n}\r\n\r\n/**\r\n * Parses CLDR time unit into `unit` and `type`.\r\n * @param  {string} CLDR_unit\r\n * @return {object} `{ type, unit }`.\r\n */\r\nfunction parse_unit(unit)\r\n{\r\n\tif (narrow.test(unit))\r\n\t{\r\n\t\treturn { type: 'narrow', unit: unit.replace(narrow, '') }\r\n\t}\r\n\r\n\tif (short.test(unit))\r\n\t{\r\n\t\treturn { type: 'short', unit: unit.replace(short, '') }\r\n\t}\r\n\r\n\treturn { type: 'long', unit }\r\n}"]}