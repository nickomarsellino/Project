{"version":3,"sources":["../source/grade.js"],"names":["grade","elapsed","now","units","gradation","get_allowed_steps","length","i","find_gradation_step","step","granularity","amount","Math","round","factor","get_threshold","from_step","to_step","threshold","id","unit","undefined","type","Error","JSON","stringify","filter","indexOf"],"mappings":";;;;;;;;kBAuBwBA,K;;AAvBxB;;AAEA;;;;;;;;;;;;;;;;;;;;;AAqBe,SAASA,KAAT,CAAeC,OAAf,EAAwBC,GAAxB,EAA6BC,KAA7B,EACf;AAAA,KADmDC,SACnD;;AACC;AACA;AACAA,aAAYC,kBAAkBD,SAAlB,EAA6BD,KAA7B,CAAZ;;AAEA;AACA;AACA,KAAIC,UAAUE,MAAV,KAAqB,CAAzB,EACA;AACC;AACA;;AAED;AACA,KAAMC,IAAIC,oBAAoBP,OAApB,EAA6BC,GAA7B,EAAkCE,SAAlC,CAAV;AACA,KAAMK,OAAOL,UAAUG,CAAV,CAAb;;AAEA;AACA;AACA;AACA,KAAIA,MAAM,CAAC,CAAX,EACA;AACC;AACA;;AAED;AACA;AACA;AACA;AACA,KAAIE,KAAKC,WAAT,EACA;AACC;AACA,MAAMC,SAASC,KAAKC,KAAL,CAAYZ,UAAUQ,KAAKK,MAAhB,GAA0BL,KAAKC,WAA1C,IAAyDD,KAAKC,WAA7E;;AAEA;AACA;AACA;AACA;AACA,MAAIC,WAAW,CAAX,IAAgBJ,IAAI,CAAxB,EACA;AACC,UAAOH,UAAUG,IAAI,CAAd,CAAP;AACA;AACD;;AAED,QAAOE,IAAP;AACA;;AAED;;;;;;;;AAQA,SAASM,aAAT,CAAuBC,SAAvB,EAAkCC,OAAlC,EAA2Cf,GAA3C,EACA;AACC,KAAIgB,kBAAJ;;AAEA;AACA;AACA,KAAIF,cAAcA,UAAUG,EAAV,IAAgBH,UAAUI,IAAxC,CAAJ,EACA;AACCF,cAAYD,4BAAyBD,UAAUG,EAAV,IAAgBH,UAAUI,IAAnD,EAAZ;AACA;;AAED;AACA;AACA,KAAIF,cAAcG,SAAlB,EACA;AACCH,cAAYD,QAAQC,SAApB;AACA;;AAED;AACA,KAAI,OAAOA,SAAP,KAAqB,UAAzB,EACA;AACCA,cAAYA,UAAUhB,GAAV,CAAZ;AACA;;AAED;AACA,KAAIc,aAAa,OAAOE,SAAP,KAAqB,QAAtC,EACA;AACC;AACA;AACA;AACA,MAAMI,cAAcJ,SAAd,yCAAcA,SAAd,CAAN;AACA,QAAM,IAAIK,KAAJ,4FAAmGL,SAAnG,WAAkHI,IAAlH,gBAAiIE,KAAKC,SAAL,CAAeR,OAAf,CAAjI,CAAN;AACA;;AAED,QAAOC,SAAP;AACA;;AAED;;;;;;;AAOA,SAASV,mBAAT,CAA6BP,OAA7B,EAAsCC,GAAtC,EAA2CE,SAA3C,EACA;AAAA,KADsDG,CACtD,uEAD0D,CAC1D;;AACC;AACA;AACA,KAAIN,UAAUc,cAAcX,UAAUG,IAAI,CAAd,CAAd,EAAgCH,UAAUG,CAAV,CAAhC,EAA8CL,GAA9C,CAAd,EACA;AACC,SAAOK,IAAI,CAAX;AACA;;AAED;AACA,KAAIA,MAAMH,UAAUE,MAAV,GAAmB,CAA7B,EACA;AACC,SAAOC,CAAP;AACA;;AAED;AACA,QAAOC,oBAAoBP,OAApB,EAA6BC,GAA7B,EAAkCE,SAAlC,EAA6CG,IAAI,CAAjD,CAAP;AACA;;AAED;;;;;;AAMA,SAASF,iBAAT,CAA2BD,SAA3B,EAAsCD,KAAtC,EACA;AACC,QAAOC,UAAUsB,MAAV,CAAiB,gBACxB;AAAA,MAD2BN,IAC3B,QAD2BA,IAC3B;;AACC;AACA;AACA,MAAIA,IAAJ,EACA;AACC,UAAOjB,MAAMwB,OAAN,CAAcP,IAAd,KAAuB,CAA9B;AACA;;AAED;AACA;AACA,SAAO,IAAP;AACA,EAZM,CAAP;AAaA","file":"grade.js","sourcesContent":["import { convenient } from './gradation'\r\n\r\n/**\r\n * Takes seconds `elapsed` and measures them against\r\n * `gradation` to return the suitable `gradation` step.\r\n *\r\n * @param {number} elapsed - Time interval (in seconds)\r\n *\r\n * @param {string[]} units - A list of allowed time units\r\n *                           (e.g. ['second', 'minute', 'hour', …])\r\n *\r\n * @param {Object} [gradation] - Time scale gradation steps.\r\n *\r\n *                               E.g.:\r\n *                               [\r\n *                                 { unit: 'second', factor: 1 },\r\n *                                 { unit: 'minute', factor: 60, threshold: 60 },\r\n *                                 { format(), threshold: 24 * 60 * 60 },\r\n *                                 …\r\n *                               ]\r\n *\r\n * @return {?Object} `gradation` step.\r\n */\r\nexport default function grade(elapsed, now, units, gradation = convenient)\r\n{\r\n\t// Leave only allowed time measurement units.\r\n\t// E.g. omit \"quarter\" unit.\r\n\tgradation = get_allowed_steps(gradation, units)\r\n\r\n\t// If no steps of gradation fit the conditions\r\n\t// then return nothing.\r\n\tif (gradation.length === 0)\r\n\t{\r\n\t\treturn\r\n\t}\r\n\r\n\t// Find the most appropriate gradation step\r\n\tconst i = find_gradation_step(elapsed, now, gradation)\r\n\tconst step = gradation[i]\r\n\r\n\t// If time elapsed is too small and even\r\n\t// the first gradation step doesn't suit it\r\n\t// then return nothing.\r\n\tif (i === -1)\r\n\t{\r\n\t\treturn\r\n\t}\r\n\r\n\t// Apply granularity to the time amount\r\n\t// (and fall back to the previous step\r\n\t//  if the first level of granularity\r\n\t//  isn't met by this amount)\r\n\tif (step.granularity)\r\n\t{\r\n\t\t// Recalculate the elapsed time amount based on granularity\r\n\t\tconst amount = Math.round((elapsed / step.factor) / step.granularity) * step.granularity\r\n\r\n\t\t// If the granularity for this step\r\n\t\t// is too high, then fallback\r\n\t\t// to the previous step of gradation.\r\n\t\t// (if there is any previous step of gradation)\r\n\t\tif (amount === 0 && i > 0)\r\n\t\t{\r\n\t\t\treturn gradation[i - 1]\r\n\t\t}\r\n\t}\r\n\r\n\treturn step\r\n}\r\n\r\n/**\r\n * Gets threshold for moving from `from_step` to `next_step`.\r\n * @param  {Object} from_step - From step.\r\n * @param  {Object} next_step - To step.\r\n * @param  {number} now - The current timestamp.\r\n * @return {number}\r\n * @throws Will throw if no threshold is found.\r\n */\r\nfunction get_threshold(from_step, to_step, now)\r\n{\r\n\tlet threshold\r\n\r\n\t// Allows custom thresholds when moving\r\n\t// from a specific step to a specific step.\r\n\tif (from_step && (from_step.id || from_step.unit))\r\n\t{\r\n\t\tthreshold = to_step[`threshold_for_${from_step.id || from_step.unit}`]\r\n\t}\r\n\r\n\t// If no custom threshold is set for this transition\r\n\t// then use the usual threshold for the next step.\r\n\tif (threshold === undefined)\r\n\t{\r\n\t\tthreshold = to_step.threshold\r\n\t}\r\n\r\n\t// Convert threshold to a number.\r\n\tif (typeof threshold === 'function')\r\n\t{\r\n\t\tthreshold = threshold(now)\r\n\t}\r\n\r\n\t// Throw if no threshold is found.\r\n\tif (from_step && typeof threshold !== 'number')\r\n\t{\r\n\t\t// Babel transforms `typeof` into some \"branches\"\r\n\t\t// so istanbul will show this as \"branch not covered\".\r\n\t\t/* istanbul ignore next */\r\n\t\tconst type = typeof threshold\r\n\t\tthrow new Error(`Each step of a gradation must have a threshold defined except for the first one. Got \"${threshold}\", ${type}. Step: ${JSON.stringify(to_step)}`)\r\n\t}\r\n\r\n\treturn threshold\r\n}\r\n\r\n/**\r\n * @param  {number} elapsed - Time elapsed (in seconds).\r\n * @param  {number} now - Current timestamp.\r\n * @param  {Object} gradation - Gradation.\r\n * @param  {number} i - Gradation step currently being tested.\r\n * @return {number} Gradation step index.\r\n */\r\nfunction find_gradation_step(elapsed, now, gradation, i = 0)\r\n{\r\n\t// If the threshold for moving from previous step\r\n\t// to this step is too high then return the previous step.\r\n\tif (elapsed < get_threshold(gradation[i - 1], gradation[i], now))\r\n\t{\r\n\t\treturn i - 1\r\n\t}\r\n\r\n\t// If it's the last step of gradation then return it.\r\n\tif (i === gradation.length - 1)\r\n\t{\r\n\t\treturn i\r\n\t}\r\n\r\n\t// Move to the next step.\r\n\treturn find_gradation_step(elapsed, now, gradation, i + 1)\r\n}\r\n\r\n/**\r\n * Leaves only allowed gradation steps.\r\n * @param  {Object[]} gradation\r\n * @param  {string[]} units - Allowed time units.\r\n * @return {Object[]}\r\n */\r\nfunction get_allowed_steps(gradation, units)\r\n{\r\n\treturn gradation.filter(({ unit }) =>\r\n\t{\r\n\t\t// If this step has a `unit` defined\r\n\t\t// then this `unit` must be in the list of `units` allowed.\r\n\t\tif (unit)\r\n\t\t{\r\n\t\t\treturn units.indexOf(unit) >= 0\r\n\t\t}\r\n\r\n\t\t// A gradation step is not required to specify a `unit`.\r\n\t\t// E.g. for Twitter gradation it specifies `format()` instead.\r\n\t\treturn true\r\n\t})\r\n}"]}