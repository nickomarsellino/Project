{"version":3,"sources":["../source/RelativeTimeFormat.js"],"names":["loadLocale","RelativeTimeFormat","locales","options","style","locale","supportedLocalesOf","resolveLocale","getDefaultLocale","value","unit","getRule","replace","Math","abs","rule","valueIndex","indexOf","parts","push","type","slice","String","length","RangeError","unitRules","getLocales","quantifierRules","quantify","quantifier","other","filter","split","pop","join","default_locale"],"mappings":"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","file":"RelativeTimeFormat.js","sourcesContent":["import JavascriptTimeAgo from './JavascriptTimeAgo'\r\n\r\n/**\r\n * Polyfill for `Intl.RelativeTimeFormat` proposal.\r\n * https://github.com/tc39/proposal-intl-relative-time\r\n * https://github.com/tc39/proposal-intl-relative-time/issues/55\r\n */\r\nexport default class RelativeTimeFormat {\r\n  /**\r\n   * @param {(string|string[])} [locales] - Preferred locales (or locale).\r\n   * @param {Object} [options] - Formatting options.\r\n   * @param {string} [options.style=\"long\"] - One of: \"long\", \"short\", \"narrow\".\r\n   * @param {string} [options.type=\"numeric\"] - One of: \"numeric\", \"text\".\r\n   * @param {string} [options.localeMatcher=\"best fit\"] - One of: \"lookup\", \"best fit\".\r\n   */\r\n  constructor(locales, options = {}) {\r\n    const { style } = options\r\n    this.style = style || 'long'\r\n\r\n    // Choose the most appropriate locale.\r\n    // This could implement some kind of a \"best-fit\" algorythm.\r\n    if (locales) {\r\n      this.locale = RelativeTimeFormat.supportedLocalesOf(locales)[0]\r\n    }\r\n    this.locale = this.locale ? resolveLocale(this.locale) : getDefaultLocale()\r\n  }\r\n\r\n  /**\r\n   * Formats time `value` in `units` (either in past or in future).\r\n   * @param {number} value - Time interval value.\r\n   * @param {string} unit - Time interval measurement unit.\r\n   * @return {string}\r\n   * @throws {RangeError} If unit is not one of \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\".\r\n   * @example\r\n   * // Returns \"2 days ago\"\r\n   * rtf.format(-2, \"day\")\r\n   * // Returns \"in 5 minutes\"\r\n   * rtf.format(5, \"minute\")\r\n   */\r\n  format(value, unit) {\r\n    return this.getRule(value, unit).replace('{0}', Math.abs(value))\r\n  }\r\n\r\n  /**\r\n   * Formats time `value` in `units` (either in past or in future).\r\n   * @param {number} value - Time interval value.\r\n   * @param {string} unit - Time interval measurement unit.\r\n   * @return {Object[]} The parts (`{ type, value }`).\r\n   * @throws {RangeError} If unit is not one of \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\".\r\n   * @example\r\n   * // Returns [\r\n   * //   { type: \"literal\", value: \"in \"},\r\n   * //   { type: \"day\", value: \"100\"},\r\n   * //   { type: \"literal\", value: \" days\"}\r\n   * // ]\r\n   * rtf.formatToParts(100, \"day\")\r\n   */\r\n  formatToParts(value, unit) {\r\n    const rule = this.getRule(value, unit)\r\n    const valueIndex = rule.indexOf(\"{0}\")\r\n    const parts = []\r\n    if (valueIndex > 0) {\r\n      parts.push({\r\n        type: \"literal\",\r\n        value: rule.slice(0, valueIndex)\r\n      })\r\n    }\r\n    parts.push({\r\n      type: unit,\r\n      value: String(Math.abs(value))\r\n    })\r\n    if (valueIndex + \"{0}\".length < rule.length - 1) {\r\n      parts.push({\r\n        type: \"literal\",\r\n        value: rule.slice(valueIndex + \"{0}\".length)\r\n      })\r\n    }\r\n    return parts\r\n  }\r\n\r\n  /**\r\n   * Returns formatting rule for `value` in `units` (either in past or in future).\r\n   * @param {number} value - Time interval value.\r\n   * @param {string} unit - Time interval measurement unit.\r\n   * @return {string}\r\n   * @throws {RangeError} If unit is not one of \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\".\r\n   * @example\r\n   * // Returns \"{0} days ago\"\r\n   * getRule(-2, \"day\")\r\n   */\r\n  getRule(value, unit) {\r\n    // \"now\" is used in `javascript-time-ago`.\r\n    if ([\"now\", \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\", \"year\"].indexOf(unit) < 0) {\r\n      throw new RangeError(`Unknown time unit: ${unit}.`)\r\n    }\r\n    // Get locale-specific time interval formatting rules\r\n    // of a given `style` for the given value of measurement `unit`.\r\n    //\r\n    // E.g.:\r\n    //\r\n    // ```json\r\n    // {\r\n    //  \"past\": {\r\n    //    \"one\": \"a second ago\",\r\n    //    \"other\": \"{0} seconds ago\"\r\n    //  },\r\n    //  \"future\": {\r\n    //    \"one\": \"in a second\",\r\n    //    \"other\": \"in {0} seconds\"\r\n    //  }\r\n    // }\r\n    // ```\r\n    //\r\n    const unitRules = getLocales()[this.locale][this.style][unit]\r\n    if (typeof unitRules === \"string\") {\r\n      return unitRules\r\n    }\r\n    // Choose either \"past\" or \"future\" based on time `value` sign.\r\n    // If \"past\" is same as \"future\" then they're stored as \"other\".\r\n    // If there's only \"other\" then it's being collapsed.\r\n    const quantifierRules = unitRules[value <= 0 ? \"past\" : \"future\"] || unitRules\r\n    if (typeof quantifierRules === \"string\") {\r\n      return quantifierRules\r\n    }\r\n    // Quantify `value`.\r\n    const quantify = getLocales()[this.locale].quantify\r\n    let quantifier = quantify && quantify(Math.abs(value))\r\n    // There seems to be no such locale in CLDR\r\n    // for which `quantify` is missing\r\n    // and still `past` and `future` messages\r\n    // contain something other than \"other\".\r\n    /* istanbul ignore next */\r\n    quantifier = quantifier || 'other'\r\n    // \"other\" rule is supposed to always be present.\r\n    // If only \"other\" rule is present then \"rules\" is not an object and is a string.\r\n    return quantifierRules[quantifier] || quantifierRules.other\r\n  }\r\n\r\n  /**\r\n   * Returns a new object with properties reflecting the locale and date and time formatting options computed during initialization of this DateTimeFormat object.\r\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/resolvedOptions\r\n   * @return {Object}\r\n   */\r\n  resolvedOptions() {\r\n    return {\r\n      locale: this.locale\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Returns an array containing those of the provided locales\r\n * that are supported in collation without having to fall back\r\n * to the runtime's default locale.\r\n * @param {(string|string[])} locale - A string with a BCP 47 language tag, or an array of such strings. For the general form of the locales argument, see the Intl page.\r\n * @param {Object} [options] - An object that may have the following property:\r\n * @param {Function} [options.localeMatcher] - The locale matching algorithm to use. Possible values are \"lookup\" and \"best fit\"; the default is \"best fit\". For information about this option, see the Intl page.\r\n * @return {string[]} An array of strings representing a subset of the given locale tags that are supported in collation without having to fall back to the runtime's default locale.\r\n * @example\r\n * var locales = ['ban', 'id-u-co-pinyin', 'de-ID'];\r\n * var options = { localeMatcher: 'lookup' };\r\n * console.log(Intl.RelativeTimeFormat.supportedLocalesOf(locales, options).join(', '));\r\n * // → \"id-u-co-pinyin, de-ID\"\r\n */\r\nRelativeTimeFormat.supportedLocalesOf = function(locales, options) {\r\n  // Convert `locales` to an array.\r\n  if (typeof locales === 'string') {\r\n    locales = [locales]\r\n  }\r\n  // This is not an intelligent algorythm,\r\n  // but it will do for the polyfill purposes.\r\n  // This could implement some kind of a \"best-fit\" algorythm.\r\n  return locales.filter(resolveLocale)\r\n}\r\n\r\n/**\r\n * Resolves a locale to a supported one.\r\n * @param  {string} locale\r\n * @return {string}\r\n */\r\nfunction resolveLocale(locale) {\r\n  if (getLocales()[locale]) {\r\n    return locale\r\n  }\r\n  // `sr-Cyrl-BA` -> `sr-Cyrl` -> `sr`.\r\n  const parts = locale.split('-')\r\n  while (locale.length > 1) {\r\n    parts.pop()\r\n    locale = parts.join('-')\r\n    if (getLocales()[locale]) {\r\n      return locale\r\n    }\r\n  }\r\n}\r\n\r\nexport function loadLocale(locale) {\r\n  JavascriptTimeAgo.locale(locale)\r\n}\r\n\r\nfunction getLocales() {\r\n  return JavascriptTimeAgo.locales\r\n}\r\n\r\nfunction getDefaultLocale() {\r\n  return JavascriptTimeAgo.default_locale\r\n}\r\n\r\n/**\r\n * Extracts language from an IETF BCP 47 language tag.\r\n * @param {string} languageTag - IETF BCP 47 language tag.\r\n * @return {string}\r\n * @example\r\n * // Returns \"he\"\r\n * getLanguageFromLanguageTag(\"he-IL-u-ca-hebrew-tz-jeruslm\")\r\n * // Returns \"ar\"\r\n * getLanguageFromLanguageTag(\"ar-u-nu-latn\")\r\n */\r\n// export function getLanguageFromLanguageTag(languageTag) {\r\n//   const hyphenIndex = languageTag.indexOf('-')\r\n//   if (hyphenIndex > 0) {\r\n//     return languageTag.slice(0, hyphenIndex)\r\n//   }\r\n//   return languageTag\r\n// }"]}